{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to the SAFE documentation site! This site contains all the documentation you'll need to quickly starting creating SAFE apps in F#. If you've not heard of SAFE before, please feel free to start with the \nintroduction\n. Alternatively, you can immediately try out the \nquick start\n guide and tutorial, or simply browse through the documentation.\n\n\nIf there's anything missing from here, please feel free to add the documentation directly (or supply an issue) to the \nGitHub repository\n.\n\n\nWe hope you enjoy using SAFE as much as we do!\n\n\nThe SAFE team.", 
            "title": "Home"
        }, 
        {
            "location": "/intro/", 
            "text": "What is SAFE?\n\n\nThe SAFE stack is an \nopen-source, free, flexible\n end-to-end, \nfunctional-first\n stack for \ncloud-ready web applications\n that emphasizes \ntype-safe programming\n.\n\n\nThe SAFE stack allows you to \ndevelop web applications\n almost entirely in \nF#\n, without needing to compromise and shoehorn your codebase into an object-oriented framework or library, and without needing you to be an expert in CSS or HTML to create compelling, rich client-side web applications.\n\n\nThe SAFE stack is made up of four components:\n\n\n\n\nA \nweb server\n running on .NET Core for hosting back-end services in F#\n\n\nA \nhosting platform\n that provides simple, scalable deployment models plus associated platform services for application developers\n\n\nA mechanism to run F# in the web browser for \nclient-side delivery of F#\n\n\nAn F# programming model for \nclient-side user interfaces\n\n\n\n\nWhy SAFE?\n\n\nSAFE provides developers with a simple and consistent programming model for developing rich, scalable web-enabled applications that can run on multiple platforms. SAFE takes advantage of F#'s mix of a functional-first experience backed by the powerful and mature .NET framework to provide a type-safe, reliable experience that leads to the \"pit of success\".\n\n\n\n\nCreate client / server applications entirely in F#\n\n\nRe-use development skills on client and server\n\n\nRapidly create rich client-side web applications with no Javascript knowledge\n\n\nRuns on the latest .NET Core (and tested daily by Microsoft)\n\n\nRapid development cycle with support for \nhot module replacement\n\n\nInteract with native Javascript libraries whenever needed\n\n\nCreate client-side applications purely in F#, with full type checking for safety\n\n\nSeamlessly share code between client and server", 
            "title": "Introduction"
        }, 
        {
            "location": "/intro/#what-is-safe", 
            "text": "The SAFE stack is an  open-source, free, flexible  end-to-end,  functional-first  stack for  cloud-ready web applications  that emphasizes  type-safe programming .  The SAFE stack allows you to  develop web applications  almost entirely in  F# , without needing to compromise and shoehorn your codebase into an object-oriented framework or library, and without needing you to be an expert in CSS or HTML to create compelling, rich client-side web applications.  The SAFE stack is made up of four components:   A  web server  running on .NET Core for hosting back-end services in F#  A  hosting platform  that provides simple, scalable deployment models plus associated platform services for application developers  A mechanism to run F# in the web browser for  client-side delivery of F#  An F# programming model for  client-side user interfaces", 
            "title": "What is SAFE?"
        }, 
        {
            "location": "/intro/#why-safe", 
            "text": "SAFE provides developers with a simple and consistent programming model for developing rich, scalable web-enabled applications that can run on multiple platforms. SAFE takes advantage of F#'s mix of a functional-first experience backed by the powerful and mature .NET framework to provide a type-safe, reliable experience that leads to the \"pit of success\".   Create client / server applications entirely in F#  Re-use development skills on client and server  Rapidly create rich client-side web applications with no Javascript knowledge  Runs on the latest .NET Core (and tested daily by Microsoft)  Rapid development cycle with support for  hot module replacement  Interact with native Javascript libraries whenever needed  Create client-side applications purely in F#, with full type checking for safety  Seamlessly share code between client and server", 
            "title": "Why SAFE?"
        }, 
        {
            "location": "/quickstart/", 
            "text": "This page provides some basic guidance on getting up and running with your first SAFE application.\n\n\nInstall pre-requisites\n\n\nYou'll need to install the following pre-requisites in order to build SAFE applications\n\n\n\n\nThe \n.NET Core SDK 2.1\n.\n\n\nFAKE 5\n installed as a \nglobal tool\n\n\nThe \nYarn\n package manager.\n\n\nNode 8.x\n installed for the front end components.\n\n\nIf you're running on OSX or Linux, you'll also need to install \nMono\n.\n\n\n\n\nInstall an F# code editor\n\n\nYou'll also want an IDE to create F# applications. We recommend one of the following great IDEs.\n\n\n\n\nVS Code\n + \nIonide\n extension\n\n\nVisual Studio 2017\n\n\nJetbrains Rider\n\n\n\n\nCreate your first SAFE app\n\n\n\n\nCreate a new directory on your machine\n\n\nOpen a command prompt\n\n\nEnter \ndotnet new -i SAFE.Template\n to install the \nSAFE project template\n\n\nEnter \ndotnet new SAFE\n to create a new SAFE project\n\n\nEnter \nfake run build.fsx --target run\n to build and run the app\n\n\n\n\nCongratulations - after a short delay, you'll be presented with a basic SAFE application running in your browser! The application will by default run in \"development mode\", which means it automatically watch your project for changes; whenever you save a file in the client project it will refresh the browser \nautomatically\n; if you save a file in the server project it will also restart the server in the background.\n\n\nTake a look at the \ntemplate options\n. There are several ways to customise the default application, such as server and client/server communication technologies.", 
            "title": "Quick Start"
        }, 
        {
            "location": "/quickstart/#install-pre-requisites", 
            "text": "You'll need to install the following pre-requisites in order to build SAFE applications   The  .NET Core SDK 2.1 .  FAKE 5  installed as a  global tool  The  Yarn  package manager.  Node 8.x  installed for the front end components.  If you're running on OSX or Linux, you'll also need to install  Mono .", 
            "title": "Install pre-requisites"
        }, 
        {
            "location": "/quickstart/#install-an-f-code-editor", 
            "text": "You'll also want an IDE to create F# applications. We recommend one of the following great IDEs.   VS Code  +  Ionide  extension  Visual Studio 2017  Jetbrains Rider", 
            "title": "Install an F# code editor"
        }, 
        {
            "location": "/quickstart/#create-your-first-safe-app", 
            "text": "Create a new directory on your machine  Open a command prompt  Enter  dotnet new -i SAFE.Template  to install the  SAFE project template  Enter  dotnet new SAFE  to create a new SAFE project  Enter  fake run build.fsx --target run  to build and run the app   Congratulations - after a short delay, you'll be presented with a basic SAFE application running in your browser! The application will by default run in \"development mode\", which means it automatically watch your project for changes; whenever you save a file in the client project it will refresh the browser  automatically ; if you save a file in the server project it will also restart the server in the background.  Take a look at the  template options . There are several ways to customise the default application, such as server and client/server communication technologies.", 
            "title": "Create your first SAFE app"
        }, 
        {
            "location": "/overview/", 
            "text": "SAFE Stack components\n\n\nThe SAFE acronym is made up of four separate components:\n\n\n\n\nS\naturn\n for back-end services in F#\n\n\nA\nzure\n as a hosting platform plus associated platform services\n\n\nF\nable\n for running F# in the web browser\n\n\nE\nlmish\n for client-side user interfaces\n\n\n\n\n\n\nSaturn\n\n\nThe Saturn library builds on top of the solid foundation of both the F#-friendly \nGiraffe\n and the high performance, rock-solid \nASP .NET Core\n web server to provide a set of optional abstractions which make configuring web applications and constructing complex routes extremely easy to achieve.\n\n\nSaturn can host RESTful API endpoints, drive static websites or server-generated content, all inside an easy-to-learn functional programming model.\n\n\nMicrosoft Azure\n\n\nAzure is a comprehensive set of cloud services that developers and IT professionals use to build, deploy and manage applications through a global network of data centres. Integrated tools, DevOps and a marketplace support you in efficiently building anything from simple mobile apps to Internet-scale solutions.\n\n\nFable\n\n\nFable is an F# to JavaScript compiler powered by Babel, designed to produce readable and standard code. Fable allows you to create applications for the browser written entirely in F#, whilst also allowing you to interact with native Javascript as needed.\n\n\nElmish\n\n\nThe Elmish model allows you to construct user interfaces running in the browser using a functional programming model. Modelled on the Elm application model, Elmish uses the Model-View-Update paradigm to allow you to write applications that are simple to reason about. Elmish sits on top of the \nReact\n framework.\n\n\nFurther reading\n\n\nPlease also feel free to read this \nblog series\n on the Compositional IT website for more details on the history of SAFE.\n\n\nAre there alternative components in the SAFE stack?\n\n\nYes, absolutely. The above components are what we recommended as the default SAFE stack, but you can of course replace the components with alternatives as you see fit. Here are some alternative technologies which are also recommended by the SAFE team if the basic stack does not fit your needs:\n\n\n\n\nGiraffe\n is a programming model designed for F# that runs on ASP .NET Core. As Saturn runs on top of Giraffe, you automatically get full access to it, but nonetheless it is entirely possible to write applications solely in Giraffe.\n\n\nFreya\n is an alternative F#-first web stack which has a pluggable runtime model which allows it to be hosted in a variety of web servers including ASP .NET Core.\n\n\nAWS\n is Amazon's cloud compute offering, providing a large number of services available globally.\n\n\nWebSharper\n is a complete end-to-end programming stack, comprising both server- and client-side components. It supports both F# and C# programming models.", 
            "title": "SAFE Stack Overview"
        }, 
        {
            "location": "/overview/#safe-stack-components", 
            "text": "The SAFE acronym is made up of four separate components:   S aturn  for back-end services in F#  A zure  as a hosting platform plus associated platform services  F able  for running F# in the web browser  E lmish  for client-side user interfaces", 
            "title": "SAFE Stack components"
        }, 
        {
            "location": "/overview/#saturn", 
            "text": "The Saturn library builds on top of the solid foundation of both the F#-friendly  Giraffe  and the high performance, rock-solid  ASP .NET Core  web server to provide a set of optional abstractions which make configuring web applications and constructing complex routes extremely easy to achieve.  Saturn can host RESTful API endpoints, drive static websites or server-generated content, all inside an easy-to-learn functional programming model.", 
            "title": "Saturn"
        }, 
        {
            "location": "/overview/#microsoft-azure", 
            "text": "Azure is a comprehensive set of cloud services that developers and IT professionals use to build, deploy and manage applications through a global network of data centres. Integrated tools, DevOps and a marketplace support you in efficiently building anything from simple mobile apps to Internet-scale solutions.", 
            "title": "Microsoft Azure"
        }, 
        {
            "location": "/overview/#fable", 
            "text": "Fable is an F# to JavaScript compiler powered by Babel, designed to produce readable and standard code. Fable allows you to create applications for the browser written entirely in F#, whilst also allowing you to interact with native Javascript as needed.", 
            "title": "Fable"
        }, 
        {
            "location": "/overview/#elmish", 
            "text": "The Elmish model allows you to construct user interfaces running in the browser using a functional programming model. Modelled on the Elm application model, Elmish uses the Model-View-Update paradigm to allow you to write applications that are simple to reason about. Elmish sits on top of the  React  framework.", 
            "title": "Elmish"
        }, 
        {
            "location": "/overview/#further-reading", 
            "text": "Please also feel free to read this  blog series  on the Compositional IT website for more details on the history of SAFE.", 
            "title": "Further reading"
        }, 
        {
            "location": "/overview/#are-there-alternative-components-in-the-safe-stack", 
            "text": "Yes, absolutely. The above components are what we recommended as the default SAFE stack, but you can of course replace the components with alternatives as you see fit. Here are some alternative technologies which are also recommended by the SAFE team if the basic stack does not fit your needs:   Giraffe  is a programming model designed for F# that runs on ASP .NET Core. As Saturn runs on top of Giraffe, you automatically get full access to it, but nonetheless it is entirely possible to write applications solely in Giraffe.  Freya  is an alternative F#-first web stack which has a pluggable runtime model which allows it to be hosted in a variety of web servers including ASP .NET Core.  AWS  is Amazon's cloud compute offering, providing a large number of services available globally.  WebSharper  is a complete end-to-end programming stack, comprising both server- and client-side components. It supports both F# and C# programming models.", 
            "title": "Are there alternative components in the SAFE stack?"
        }, 
        {
            "location": "/component-saturn/", 
            "text": "Saturn\n in SAFE\n\n\nSaturn is a web development library written in F# which allows you to easily create both server-side MVC applications as well as web APIs. It runs on top of two other components:\n\n\n\n\nGiraffe\n, an F#-specific library for writing functional-first web applications.\n\n\nMicrosoft's \nASP .NET Core\n.\n\n\n\n\nSaturn, via Giraffe, provides very good integration with other ASP.NET Core components such as authentication.\n\n\nMany of Saturn's components and concepts will seem familiar to those of us with experience of other web frameworks such as Ruby on Rails, Python\u2019s Django or especially Elixir's \nPhoenix\n.\n\n\nHow does Saturn integrate with SAFE?\n\n\nSaturn provides the ability to drive your SAFE applications from the server. It enables:\n\n\n\n\nRouting and hosting of your server-side APIs through a set of simple-to-use abstractions.\n\n\nHosting of your client-side assets, such as HTML, CSS and JavaScript generated by Fable.\n\n\nOther cross cutting concerns e.g. authentication etc.\n\n\n\n\nIt also integrates with SAFE to allow seamless sharing of types and functions, since Fable will convert most F# into JavaScript. In addition, you can seamless transport data between client and server using either the Fable.JSON or Fable.Remoting libraries, both of which have support for Saturn. You can read more about this \nhere\n.\n\n\n\n\nLearn more about Saturn \nhere\n.", 
            "title": "Learn about Saturn"
        }, 
        {
            "location": "/component-saturn/#saturn-in-safe", 
            "text": "Saturn is a web development library written in F# which allows you to easily create both server-side MVC applications as well as web APIs. It runs on top of two other components:   Giraffe , an F#-specific library for writing functional-first web applications.  Microsoft's  ASP .NET Core .   Saturn, via Giraffe, provides very good integration with other ASP.NET Core components such as authentication.  Many of Saturn's components and concepts will seem familiar to those of us with experience of other web frameworks such as Ruby on Rails, Python\u2019s Django or especially Elixir's  Phoenix .", 
            "title": "Saturn in SAFE"
        }, 
        {
            "location": "/component-saturn/#how-does-saturn-integrate-with-safe", 
            "text": "Saturn provides the ability to drive your SAFE applications from the server. It enables:   Routing and hosting of your server-side APIs through a set of simple-to-use abstractions.  Hosting of your client-side assets, such as HTML, CSS and JavaScript generated by Fable.  Other cross cutting concerns e.g. authentication etc.   It also integrates with SAFE to allow seamless sharing of types and functions, since Fable will convert most F# into JavaScript. In addition, you can seamless transport data between client and server using either the Fable.JSON or Fable.Remoting libraries, both of which have support for Saturn. You can read more about this  here .   Learn more about Saturn  here .", 
            "title": "How does Saturn integrate with SAFE?"
        }, 
        {
            "location": "/component-azure/", 
            "text": "Azure\n in SAFE\n\n\nWhat is Azure?\n\n\nAzure is a comprehensive set of cloud services that developers and IT professionals use to build, deploy and manage applications through a global network of data centres. Integrated tools, DevOps and a marketplace support you in efficiently building anything from simple mobile apps to Internet-scale solutions.\n\n\nHow does Azure integrate with SAFE?\n\n\nAzure provides a number of flexible services for SAFE applications, including (but not only):\n\n\nHosting Services\n\n\nAzure comes with several ready-made hosting services, including \nApp Service\n, which enables seamless hosting of web applications, including ASP .NET Core applications (which \nSaturn\n is built on top of). In addition, Azure supports a number of managed \nhosting services\n for \nDocker\n and \nKubernetes\n, which work fantastically well with SAFE.\n\n\nPlatform Services\n\n\nAzure comes with a large number of ready-made platform services that can \ndramatically lower the cost\n of developing bespoke systems, including:\n\n\n\n\nCompute\n services such as \nAzure Functions\n, for hosting F# code that can dynamically scale based on load, as well as \nService Fabric\n or \nVirtual Machines\n.\n\n\nStorage\n services such as \nAzure Storage\n and \nData Lake\n, for storing virtually limitless volumes of data in unstructured or structure form.\n\n\nDatabase\n services, including managed \nSQL Server\n, \nMySQL\n and \nPostgres\n, as well as \nCosmosDB\n for document and graph stores, \nRedis\n and more.\n\n\nMessaging\n services including \nQueues\n, \nService Bus\n and \nEvent Hub\n.\n\n\nAnalytical\n services such as \nStream Analytics\n, \nDatabricks\n, \nMachine Learning\n and \nAnalysis Services\n.\n\n\nSecurity\n services such as \nKey Vault\n and \nActive Directory\n.\n\n\n\n\nMany of the above services have ready-made SDKs that can be run on .NET and therefore from F#. In addition, the \nAzure Storage Type Provider\n provides unparallel ease of access to Azure Storage Blobs, Queues and Tables from F# \n(currently not yet supported on .NET Core)\n.", 
            "title": "Learn about Azure"
        }, 
        {
            "location": "/component-azure/#azure-in-safe", 
            "text": "", 
            "title": "Azure in SAFE"
        }, 
        {
            "location": "/component-azure/#what-is-azure", 
            "text": "Azure is a comprehensive set of cloud services that developers and IT professionals use to build, deploy and manage applications through a global network of data centres. Integrated tools, DevOps and a marketplace support you in efficiently building anything from simple mobile apps to Internet-scale solutions.", 
            "title": "What is Azure?"
        }, 
        {
            "location": "/component-azure/#how-does-azure-integrate-with-safe", 
            "text": "Azure provides a number of flexible services for SAFE applications, including (but not only):", 
            "title": "How does Azure integrate with SAFE?"
        }, 
        {
            "location": "/component-azure/#hosting-services", 
            "text": "Azure comes with several ready-made hosting services, including  App Service , which enables seamless hosting of web applications, including ASP .NET Core applications (which  Saturn  is built on top of). In addition, Azure supports a number of managed  hosting services  for  Docker  and  Kubernetes , which work fantastically well with SAFE.", 
            "title": "Hosting Services"
        }, 
        {
            "location": "/component-azure/#platform-services", 
            "text": "Azure comes with a large number of ready-made platform services that can  dramatically lower the cost  of developing bespoke systems, including:   Compute  services such as  Azure Functions , for hosting F# code that can dynamically scale based on load, as well as  Service Fabric  or  Virtual Machines .  Storage  services such as  Azure Storage  and  Data Lake , for storing virtually limitless volumes of data in unstructured or structure form.  Database  services, including managed  SQL Server ,  MySQL  and  Postgres , as well as  CosmosDB  for document and graph stores,  Redis  and more.  Messaging  services including  Queues ,  Service Bus  and  Event Hub .  Analytical  services such as  Stream Analytics ,  Databricks ,  Machine Learning  and  Analysis Services .  Security  services such as  Key Vault  and  Active Directory .   Many of the above services have ready-made SDKs that can be run on .NET and therefore from F#. In addition, the  Azure Storage Type Provider  provides unparallel ease of access to Azure Storage Blobs, Queues and Tables from F#  (currently not yet supported on .NET Core) .", 
            "title": "Platform Services"
        }, 
        {
            "location": "/component-fable/", 
            "text": "Fable\n in SAFE\n\n\nWhat is Fable?\n\n\nFable is an F#-to-JavaScript (JS) compiler powered by \nBabel\n, designed to produce readable and standard JS code. Fable brings all the power of F# to the JS ecosystem, with support for most of the F# core library as well the most commonly used .NET APIs.\n\n\nHow does Fable integrate with SAFE?\n\n\nFable is much more than an F#-to-JS compiler - it also provides \nrich\n integration with the JS ecosystem which means that you can use JS libraries from F# (and vice versa) as well as make use of standard JS tools. There are two \"sides\" to Fable that work together to allow F# to run within the JS world - a .NET tooling component and a JS tooling component:\n\n\n\n\nIt's important to understand the Fable is not simply an application that takes in F# and emits JS - instead, the dotnet fable application emits an intermediary file (a Babel Abstract Syntax Tree), which in turn is converted by webpack into well-written JS.\n\n\nFable and webpack\n\n\nFable's \"JavaScript\" side is normally hosted within the context of \nwebpack\n, a powerful bundling tool. You'll normally see a \nwebpack.config.js\n file in the client folder of your SAFE applications. This file tells webpack how to emit JS from F# files and hosts the Fable webpack plugin, \nfable-loader\n.\n\n\nUsing webpack also provides many advantages - for example, we as developers can control how JS is rendered through standard tools that exist in the JS ecosystem, whilst also using features such as \nHot Module replacement\n and Source Maps.\n\n\nCreating a webpack config file isn't the easiest thing in the world, so the \nSAFE Template\n already has one pre-built that contains the basics to get you up and running immediately.\n\n\nLearn more about Fable \nhere\n.", 
            "title": "Learn about Fable"
        }, 
        {
            "location": "/component-fable/#fable-in-safe", 
            "text": "", 
            "title": "Fable in SAFE"
        }, 
        {
            "location": "/component-fable/#what-is-fable", 
            "text": "Fable is an F#-to-JavaScript (JS) compiler powered by  Babel , designed to produce readable and standard JS code. Fable brings all the power of F# to the JS ecosystem, with support for most of the F# core library as well the most commonly used .NET APIs.", 
            "title": "What is Fable?"
        }, 
        {
            "location": "/component-fable/#how-does-fable-integrate-with-safe", 
            "text": "Fable is much more than an F#-to-JS compiler - it also provides  rich  integration with the JS ecosystem which means that you can use JS libraries from F# (and vice versa) as well as make use of standard JS tools. There are two \"sides\" to Fable that work together to allow F# to run within the JS world - a .NET tooling component and a JS tooling component:   It's important to understand the Fable is not simply an application that takes in F# and emits JS - instead, the dotnet fable application emits an intermediary file (a Babel Abstract Syntax Tree), which in turn is converted by webpack into well-written JS.", 
            "title": "How does Fable integrate with SAFE?"
        }, 
        {
            "location": "/component-fable/#fable-and-webpack", 
            "text": "Fable's \"JavaScript\" side is normally hosted within the context of  webpack , a powerful bundling tool. You'll normally see a  webpack.config.js  file in the client folder of your SAFE applications. This file tells webpack how to emit JS from F# files and hosts the Fable webpack plugin,  fable-loader .  Using webpack also provides many advantages - for example, we as developers can control how JS is rendered through standard tools that exist in the JS ecosystem, whilst also using features such as  Hot Module replacement  and Source Maps.  Creating a webpack config file isn't the easiest thing in the world, so the  SAFE Template  already has one pre-built that contains the basics to get you up and running immediately.  Learn more about Fable  here .", 
            "title": "Fable and webpack"
        }, 
        {
            "location": "/component-elmish/", 
            "text": "Elmish\n in SAFE\n\n\nWhat is Elmish?\n\n\nElmish is a set of simple abstractions for writing user interfaces in F# applications in a functional style following the \nmodel-view-update\n architecture made famous by \nElm\n. The Elmish library is not coupled to any specific view engine, but is intended for use in conjuction with a DOM/renderer such as React/ReactNative or VirtualDOM.\n\n\nHow does Elmish integrate with SAFE?\n\n\nElmish provides the ability to more easily create user interfaces in the browser on top of \nFable\n so that you don't have to write applications that are tightly coupled to HTML using e.g. JQuery or similar. The \nSAFE Stack templates\n comes pre-bundled with the \nElmish React\n module, which (as the name suggests) uses the \nReact\n library to handle the heavy lifting of modifyng the DOM in an efficient way. This allow us to use the pure functional style of the MVU pattern whilst still retaining the ability to have a highly performant user interface.\n\n\nThis conceptual diagram illustrates how your F# is run in the browser in a SAFE app.\n\n\n\n\nLearn more about Elmish \nhere\n.", 
            "title": "Learn about Elmish"
        }, 
        {
            "location": "/component-elmish/#elmish-in-safe", 
            "text": "", 
            "title": "Elmish in SAFE"
        }, 
        {
            "location": "/component-elmish/#what-is-elmish", 
            "text": "Elmish is a set of simple abstractions for writing user interfaces in F# applications in a functional style following the  model-view-update  architecture made famous by  Elm . The Elmish library is not coupled to any specific view engine, but is intended for use in conjuction with a DOM/renderer such as React/ReactNative or VirtualDOM.", 
            "title": "What is Elmish?"
        }, 
        {
            "location": "/component-elmish/#how-does-elmish-integrate-with-safe", 
            "text": "Elmish provides the ability to more easily create user interfaces in the browser on top of  Fable  so that you don't have to write applications that are tightly coupled to HTML using e.g. JQuery or similar. The  SAFE Stack templates  comes pre-bundled with the  Elmish React  module, which (as the name suggests) uses the  React  library to handle the heavy lifting of modifyng the DOM in an efficient way. This allow us to use the pure functional style of the MVU pattern whilst still retaining the ability to have a highly performant user interface.  This conceptual diagram illustrates how your F# is run in the browser in a SAFE app.   Learn more about Elmish  here .", 
            "title": "How does Elmish integrate with SAFE?"
        }, 
        {
            "location": "/template-overview/", 
            "text": "The \nSAFE Template\n is a \ndotnet CLI template\n for SAFE Stack projects, designed to get you up and running as quickly as possible, with flexible options to suit your application.\n\n\nThe template gets you up and running with the most common elements of the stack:\n\n\n\n\nSaturn\n or \nGiraffe\n\n\nFable\n for client-side F#\n\n\nElmish\n for web UI\n\n\nFulma\n for consistent web styling\n\n\nDocker\n or \nAzure App Service\n deployment models for hosting.\n\n\n\n\nUsing the template\n\n\nRefer to the \nQuick Start guide\n to see basic guidance on how to install and use the template.\n\n\nTemplate options\n\n\nThe template provides the ability to customise the created application. You can see template version and available options by running  \ndotnet new SAFE --help\n.\n\n\nServer\n\n\nConfigures the SAFE app to use one of three different back-end hosting platforms.\n\n\nUsage: \ndotnet new SAFE --server \nserver\n\n\nWhere \nserver\n is one of:\n\n\n\n\nsaturn\n: Creates a SAFE app running on Saturn on top of Giraffe \n(default)\n.\n\n\ngiraffe\n: Creates a SAFE app running on Giraffe only.\n\n\n\n\nLayout\n\n\nConfigures the SAFE app to apply a CSS Framework to the UI template. Currently supports just \nFulma\n bindings\n\n\nUsage: \ndotnet new SAFE --layout \nlayout\n\n\nWhere \nlayout\n is one of:\n\n\n\n\nnone\n: don't add any CSS framework.\n\n\nfulma-basic\n: adds Fulma basic template \n(default)\n.\n\n\nfulma-admin\n: adds Fulma with the \n'Admin'\n Bulma template.\n\n\nfulma-cover\n: adds Fulma with the \n'Cover'\n Bulma template.\n\n\nfulma-hero\n: adds Fulma with the \n'Hero'\n Bulma template.\n\n\nfulma-landing\n: adds Fulma with the \n'Landing'\n Bulma template.\n\n\nfulma-login\n: adds Fulma with the \n'Login'\n Bulma template.\n\n\n\n\nRemoting\n\n\nConfigures the SAFE app to use \nFable.Remoting\n to the template. If this argument is not supplied, client / server communication will be handled through the standard routing and serialization mechanism of the server. See \nhere\n for an overview of Fable Remoting and the alternatives for sharing data between client and server.\n\n\nUsage: \ndotnet new SAFE --remoting\n\n\nDeploy\n\n\nOptionally configures the SAFE app to elements needed for deploying to one of two different hosting models. If this argument is not supplied, no explicit support for any hosting model will be provided.\n\n\nUsage: \ndotnet new SAFE --deploy \nhosting model\n\n\nWhere \nhosting model\n is one of:\n\n\n\n\nnone\n: don't add FAKE targets to deploy \n(default)\n.\n\n\ndocker\n: Adds \nFAKE\n targets that bundles and build a Docker image. See \nhere\n for more details about Docker deployment.\n\n\nazure\n: Adds \nFAKE\n targets and an \nAzure Resource Manager\n (ARM) template that allows deployment to the \nAzure App Service\n plus an \nAzure Application Insights\n instance. See \nhere\n for more details about Azure deployment.\n\n\n\n\nJS Deps\n\n\nConfigures the SAFE app to use either Yarn or NPM for JS package management.\n\n\nUsage: \ndotnet new SAFE --js-deps \npackage manager\n\n\nWhere \npackage manager\n is one of:\n\n\n\n\nyarn\n: uses \nYarn\n for JS package management  \n(default)\n.\n\n\nnpm\n: uses \nNPM\n for JS package management.\n\n\n\n\nExamples\n\n\n\n\nCreate a SAFE application using all defaults: \ndotnet new SAFE\n\n\nCreate a SAFE application using Giraffe with Fable Remoting: \ndotnet new SAFE --server giraffe --remoting\n\n\nCreate a SAFE application using Giraffe with Fulma: \ndotnet new SAFE --server giraffe --layout fulma-landing", 
            "title": "SAFE Template overview"
        }, 
        {
            "location": "/template-overview/#using-the-template", 
            "text": "Refer to the  Quick Start guide  to see basic guidance on how to install and use the template.", 
            "title": "Using the template"
        }, 
        {
            "location": "/template-overview/#template-options", 
            "text": "The template provides the ability to customise the created application. You can see template version and available options by running   dotnet new SAFE --help .", 
            "title": "Template options"
        }, 
        {
            "location": "/template-overview/#server", 
            "text": "Configures the SAFE app to use one of three different back-end hosting platforms.  Usage:  dotnet new SAFE --server  server  Where  server  is one of:   saturn : Creates a SAFE app running on Saturn on top of Giraffe  (default) .  giraffe : Creates a SAFE app running on Giraffe only.", 
            "title": "Server"
        }, 
        {
            "location": "/template-overview/#layout", 
            "text": "Configures the SAFE app to apply a CSS Framework to the UI template. Currently supports just  Fulma  bindings  Usage:  dotnet new SAFE --layout  layout  Where  layout  is one of:   none : don't add any CSS framework.  fulma-basic : adds Fulma basic template  (default) .  fulma-admin : adds Fulma with the  'Admin'  Bulma template.  fulma-cover : adds Fulma with the  'Cover'  Bulma template.  fulma-hero : adds Fulma with the  'Hero'  Bulma template.  fulma-landing : adds Fulma with the  'Landing'  Bulma template.  fulma-login : adds Fulma with the  'Login'  Bulma template.", 
            "title": "Layout"
        }, 
        {
            "location": "/template-overview/#remoting", 
            "text": "Configures the SAFE app to use  Fable.Remoting  to the template. If this argument is not supplied, client / server communication will be handled through the standard routing and serialization mechanism of the server. See  here  for an overview of Fable Remoting and the alternatives for sharing data between client and server.  Usage:  dotnet new SAFE --remoting", 
            "title": "Remoting"
        }, 
        {
            "location": "/template-overview/#deploy", 
            "text": "Optionally configures the SAFE app to elements needed for deploying to one of two different hosting models. If this argument is not supplied, no explicit support for any hosting model will be provided.  Usage:  dotnet new SAFE --deploy  hosting model  Where  hosting model  is one of:   none : don't add FAKE targets to deploy  (default) .  docker : Adds  FAKE  targets that bundles and build a Docker image. See  here  for more details about Docker deployment.  azure : Adds  FAKE  targets and an  Azure Resource Manager  (ARM) template that allows deployment to the  Azure App Service  plus an  Azure Application Insights  instance. See  here  for more details about Azure deployment.", 
            "title": "Deploy"
        }, 
        {
            "location": "/template-overview/#js-deps", 
            "text": "Configures the SAFE app to use either Yarn or NPM for JS package management.  Usage:  dotnet new SAFE --js-deps  package manager  Where  package manager  is one of:   yarn : uses  Yarn  for JS package management   (default) .  npm : uses  NPM  for JS package management.", 
            "title": "JS Deps"
        }, 
        {
            "location": "/template-overview/#examples", 
            "text": "Create a SAFE application using all defaults:  dotnet new SAFE  Create a SAFE application using Giraffe with Fable Remoting:  dotnet new SAFE --server giraffe --remoting  Create a SAFE application using Giraffe with Fulma:  dotnet new SAFE --server giraffe --layout fulma-landing", 
            "title": "Examples"
        }, 
        {
            "location": "/template-fake/", 
            "text": "The template uses \nFAKE\n to build the application.\n\n\nGenerated FAKE script consist of two primary build targets, used for different purposes:\n\n\n\"Build\"\n target\n\n\nThis target is a standard build procedure, consisting of following steps:\n\n\n\n\nInstallDotNetCore\n - here, a required version of dotnet core is read from \nglobal.json\n file and if not yet installed, the script downloads and performs the installation of desired dotnet core SDK.\n\n\nInstallClient\n - in this step, either NPM or Yarn is invoked (based on which option was chosen when generating project) and it installs all Client dependencies defined in \npackage.json\n. The step also performs \ndotnet restore\n to fetch NuGet-based packages used by front-end.\n\n\nBuild\n - for server side \ndotnet build\n command is invoked, and for client side a special \ndotnet-fable\n CLI tool using \ndotnet fable webpack\n command with \n-p\n flag to compile Client project to a single JavaScript bundle file.\n\n\n\n\nNote: Extra build steps will be included if you specified the \n--deploy docker\n or \n--deploy azure\n flag when creating your project.\n\n\n\"Run\"\n target\n\n\nThis target is used for development purposes, and provides a great live-reload experience. It consists of following steps:\n\n\n\n\nInstallClient\n - same as above in \nBuild\n chain,\n\n\nRestoreServer\n - \ndotnet restore\n is invoked for Server to fetch all necessary packages (note \ndotnet build\n is skipped here),\n\n\nRun\n - most interesting part; in this step 3 separate actions are performed in parallel:\n\n\ndotnet watch run\n for Server side - compiles, runs Server and watches for changes in Server source files. Whenever a change in any source file is detected, Server is automatically stopped, recompiled and rerun in the background,\n\n\ndotnet fable webpack-dev-server\n for Client side - compiles Client to JavaScript and runs \nWebpack dev-server\n - this in turn recompiles and reloads the client application upon any source file change in Client project,\n\n\nNew process is started for \nhttp://localhost:8080\n to open the URL in default browser", 
            "title": "FAKE script"
        }, 
        {
            "location": "/template-fake/#build-target", 
            "text": "This target is a standard build procedure, consisting of following steps:   InstallDotNetCore  - here, a required version of dotnet core is read from  global.json  file and if not yet installed, the script downloads and performs the installation of desired dotnet core SDK.  InstallClient  - in this step, either NPM or Yarn is invoked (based on which option was chosen when generating project) and it installs all Client dependencies defined in  package.json . The step also performs  dotnet restore  to fetch NuGet-based packages used by front-end.  Build  - for server side  dotnet build  command is invoked, and for client side a special  dotnet-fable  CLI tool using  dotnet fable webpack  command with  -p  flag to compile Client project to a single JavaScript bundle file.   Note: Extra build steps will be included if you specified the  --deploy docker  or  --deploy azure  flag when creating your project.", 
            "title": "\"Build\" target"
        }, 
        {
            "location": "/template-fake/#run-target", 
            "text": "This target is used for development purposes, and provides a great live-reload experience. It consists of following steps:   InstallClient  - same as above in  Build  chain,  RestoreServer  -  dotnet restore  is invoked for Server to fetch all necessary packages (note  dotnet build  is skipped here),  Run  - most interesting part; in this step 3 separate actions are performed in parallel:  dotnet watch run  for Server side - compiles, runs Server and watches for changes in Server source files. Whenever a change in any source file is detected, Server is automatically stopped, recompiled and rerun in the background,  dotnet fable webpack-dev-server  for Client side - compiles Client to JavaScript and runs  Webpack dev-server  - this in turn recompiles and reloads the client application upon any source file change in Client project,  New process is started for  http://localhost:8080  to open the URL in default browser", 
            "title": "\"Run\" target"
        }, 
        {
            "location": "/template-docker/", 
            "text": "The SAFE template has the ability to easily create a \nDocker\n container. The details of the additions to the FAKE script are shown here. For this deployment option SAFE uses the Linux containers and therefore you need docker installed on your machine and configure it to run with \nLinux containers\n.\n\n\nCustom FAKE build tasks\n\n\n\n\nBundle\n - all necessary artifacts for both Server and Client are collected for following \nDocker\n target.\n\n\nDocker\n - based on present \nDockerfile\n, docker image is built and tagged using \ndockerUser\n and \ndockerImageName\n values from the script. \n\n\n\n\nDocker image\n\n\nThe image is based on \nmicrosoft/dotnet:runtime\n.\nEntrypoint for the image is \ndotnet Server.dll\n (with \n/Server\n working directory).\nTo allow incoming traffic, port 8085 is exposed.\n\n\n\n\nNote: Before running the \nDocker\n target, make sure to modify the default \ndockerUser\n and \ndockerImageName\n values in script.\n\n\n\n\nRelease to Azure App Service\n\n\nThe following part shows how to set up automatic deployment to \nMicrosoft Azure\n.\n\n\nDocker Hub\n\n\nCreate a new \nDocker Hub\n account and a new public repository on Docker Hub.\n\n\nRelease script\n\n\nCreate a file called \nrelease.cmd\n with the following content and configure your DockerHub credentials:\n\n\n@echo off\ncls\n\nfake run build.fsx --target Deploy \"DockerLoginServer=docker.io\" \"DockerImageName=****\" \"DockerUser=****\" \"DockerPassword=***\" %*\n\n\n\nDon't worry the file is already in \n.gitignore\n so your password will not be commited.\n\n\nInitial docker push\n\n\nIn order to release a container you need to create a new entry in [RELEASE_NOTES.md] and run \nrelease.cmd\n.\nThis will build the server and client, run all test, put the app into a docker container and push it to your docker hub repo.\n\n\nAzure Portal\n\n\nGo to the \nAzure Portal\n and create a new \"Web App for Containers\".\nConfigure the Web App to point to the docker repo and select \nlatest\n channel of the container.\n\n\n\n\nAlso look for the \"WebHook Url\" on the portal, copy that url and set it as new trigger in your Docker Hub repo.\n\n\nNote that entering a Startup File is not necessary.\n\n\nThe \nDockerfile\n used to create the docker image exposes port 8085 for the Giraffe server application. This port needs to be mapped to port 80 within the Azure App Service for the application to receive http traffic.\n\n\nPresently this can only be done using the Azure CLI. You can do this easily in Azure Cloud Shell (accessible from the Azure Portal in the top menu bar) using the following command:\n\n\naz webapp config appsettings set --resource-group \nresource group name\n --name \nweb app name\n --settings WEBSITES_PORT=8085\n\n\nThe above command is effectively the same as running \ndocker run -p 80:8085 \nimage name\n.\n\n\nNow you should be able to reach the website on your \n.azurewebsites.net\n url.\n\n\nFurther releases\n\n\nNow everything is set up. By creating new entries in [RELEASE_NOTES.md] and a new run of \nrelease.cmd\n the website should update automatically.\n\n\nAlternatively, you can use the \nARM delpoy option\n to do automatic deployment to the Azure App Service platform.", 
            "title": "Deploy to Docker"
        }, 
        {
            "location": "/template-docker/#custom-fake-build-tasks", 
            "text": "Bundle  - all necessary artifacts for both Server and Client are collected for following  Docker  target.  Docker  - based on present  Dockerfile , docker image is built and tagged using  dockerUser  and  dockerImageName  values from the script.", 
            "title": "Custom FAKE build tasks"
        }, 
        {
            "location": "/template-docker/#docker-image", 
            "text": "The image is based on  microsoft/dotnet:runtime .\nEntrypoint for the image is  dotnet Server.dll  (with  /Server  working directory).\nTo allow incoming traffic, port 8085 is exposed.   Note: Before running the  Docker  target, make sure to modify the default  dockerUser  and  dockerImageName  values in script.", 
            "title": "Docker image"
        }, 
        {
            "location": "/template-docker/#release-to-azure-app-service", 
            "text": "The following part shows how to set up automatic deployment to  Microsoft Azure .", 
            "title": "Release to Azure App Service"
        }, 
        {
            "location": "/template-docker/#docker-hub", 
            "text": "Create a new  Docker Hub  account and a new public repository on Docker Hub.", 
            "title": "Docker Hub"
        }, 
        {
            "location": "/template-docker/#release-script", 
            "text": "Create a file called  release.cmd  with the following content and configure your DockerHub credentials:  @echo off\ncls\n\nfake run build.fsx --target Deploy \"DockerLoginServer=docker.io\" \"DockerImageName=****\" \"DockerUser=****\" \"DockerPassword=***\" %*  Don't worry the file is already in  .gitignore  so your password will not be commited.", 
            "title": "Release script"
        }, 
        {
            "location": "/template-docker/#initial-docker-push", 
            "text": "In order to release a container you need to create a new entry in [RELEASE_NOTES.md] and run  release.cmd .\nThis will build the server and client, run all test, put the app into a docker container and push it to your docker hub repo.", 
            "title": "Initial docker push"
        }, 
        {
            "location": "/template-docker/#azure-portal", 
            "text": "Go to the  Azure Portal  and create a new \"Web App for Containers\".\nConfigure the Web App to point to the docker repo and select  latest  channel of the container.   Also look for the \"WebHook Url\" on the portal, copy that url and set it as new trigger in your Docker Hub repo.  Note that entering a Startup File is not necessary.  The  Dockerfile  used to create the docker image exposes port 8085 for the Giraffe server application. This port needs to be mapped to port 80 within the Azure App Service for the application to receive http traffic.  Presently this can only be done using the Azure CLI. You can do this easily in Azure Cloud Shell (accessible from the Azure Portal in the top menu bar) using the following command:  az webapp config appsettings set --resource-group  resource group name  --name  web app name  --settings WEBSITES_PORT=8085  The above command is effectively the same as running  docker run -p 80:8085  image name .  Now you should be able to reach the website on your  .azurewebsites.net  url.", 
            "title": "Azure Portal"
        }, 
        {
            "location": "/template-docker/#further-releases", 
            "text": "Now everything is set up. By creating new entries in [RELEASE_NOTES.md] and a new run of  release.cmd  the website should update automatically.  Alternatively, you can use the  ARM delpoy option  to do automatic deployment to the Azure App Service platform.", 
            "title": "Further releases"
        }, 
        {
            "location": "/template-appservice/", 
            "text": "The SAFE template has the ability to deploy to Azure's \nApp Service\n with minimum effort. This template mode will also create you an \nApplication Insights\n account, linked to your web application.\n\n\nWhat is Azure App Service?\n\n\nThe Azure App Service allows you to quickly build, deploy, and scale enterprise-grade web, mobile, and API apps running on any platform whilst meeting rigorous performance, scalability, security and compliance requirements using a fully-managed platform to perform infrastructure maintenance.\n\n\nIt comes in a number of pricing plans, including a free option and has options for scale-up, scale-out, turn-key authentication as well as powerful monitoring capabilities. It is compatible with many runtimes and includes excellent support for both .NET Framework and .NET Core.\n\n\nDeployment Steps\n\n\nIn order to deploy your SAFE application to the App Service, you must have first created an \nAzure Account\n, selected a \nSubscription ID\n and created an associated \nApp Registration\n.\n\n\nCustom FAKE build tasks\n\n\nThe Azure variant of the SAFE template adds the following extra build stages:\n\n\n\n\nBundle\n - Runs after the standard Build step. It combines the outputs of the Client and Server application into a single folder.\n\n\nArmTemplate\n - Deploys an Azure Resource Manager (ARM) template containing an entire environment as required by the SAFE application.\n\n\nAppService\n - Zips up the bundled folder and deploys it into the created environment.\n\n\n\n\n\n\nThere is a known issue that currently the FAKE script may sometimes fail the first time you run it with \nthis error\n. If this occurs, simply open the FAKE script in your favourite editor, add a new line anywhere in the script, save and re-run. We're looking to fix this as soon as possible!\n\n\n\n\nWhat is an ARM template?\n\n\nAn ARM template is a declarative JSON file which contains the details of the Azure resources you require in your environment. This might include a web application, database, VM and messaging service - essentially any service supported by Azure. ARM templates are smart, in that you can repeatedly deploy them over an existing environment and only the newly added elements in the template will be applied onto the environment - perfect for a CI / CD approach. This also allows you to create entire dev / test environments from scratch within just a few minutes. The ARM template that comes with the SAFE template includes everything you need for a complete deployment to Azure from a clean state.\n\n\nBuild arguments\n\n\nDeploying your application through FAKE is relatively simple. Use the following command:\n\n\nfake run build.fsx --target appservice\n    -e subscriptionId=\nsubId\n\n    -e clientId=\nclientId\n\n    -e environment=\nenvironment\n (optional)\n    -e location=\nlocation\n       (optional)\n    -e pricingTier=\npricingTier\n (optional)\n\n\n\n\nwhere:\n\n\n\n\nsubscriptionId\n is an Azure Subscription ID.\n\n\nclientId\n is the Application ID of an Azure App Registration.\n\n\nenvironment\n is an optional environment name that will be appended to all Azure resources created, which allows you to create entire dev / test environments quickly and easily. This defaults to a random GUID.\n\n\nlocation\n is the Azure data center location you wish to use. There are currently over 30 different data centers worldwide. This defaults to \nwesteurope\n; the full list can be viewed \nhere\n. The location must be supplied in lower case and without spaces.\n\n\npricingTier\n is the pricing tier of the app service that hosts your SAFE app. This defaults to F1 (free); the full list can be viewed \nhere\n.\n\n\n\n\nNote that you can also modify the FAKE script and embed both the \nsubscriptionId\n and \nclientId\n values directly in the script and commit into source control. This is completely safe to do as the Client ID is not sufficient on its own to authenticate into Azure (see below).\n\n\nInteractive deployment\n\n\nWhen running the build script, you will need to interactively authenticate with Azure in order to deploy the ARM template. During the FAKE script, you will see the following midway through the build cycle:\n\n\n\n\nNavigating to that URL will request you to input the code shown above:\n\n\n\n\nFinally, you will be prompted sign into Azure using your normal user account. After a short delay, the FAKE script will continue.\n\n\n\n\n\n\nNote: If you're getting \nFileNotFoundException\n for \nMicrosoft.Rest.ClientRuntime.Azure\n, try editing and rerunning FAKE script (\nsee details\n).\n\n\n\n\nCreating a fully automated deployment\n\n\nYou can also elect to implement a fully-automated (non-interactive) deployment model, ideal for Continuous Deployment (CD) scenarios through tools such as AppVeyor and Visual Studio Team Services, using an \nAzure Active Directory Application\n. In this model, in addition to a SubscriptionID and Client ID, you also supply a Tenant ID and an Application Secret into the FAKE script to deploy your ARM resources; these identities should normally be secured and supplied into your FAKE script as arguments rather than committed into source control.\n\n\nViewing the deployed SAFE application\n\n\nOnce the deployment is complete, you can log into the Azure Portal and see your environment being created.\n\n\n\n\nLog into the Azure Portal.\n\n\nNavigate to the Resource Groups blade and locate the newly-created group. Its name will be \nsafe-\nenvironment\n e.g. \nsafe-helloworld\n.\n\n\nNavigate to the App Service entry shown in the group following the convention \nsafe-\nenvironment\n-web\n.\n\n\nHit Browse from the new App Service blade that appears.\n\n\n\nYour application will be shown in the browser running on a url following the convention \nhttps://safe-\nenvironment\n-web.azurewebsites.net/\n.\n\n\n\n\nYou can also \ndeploy to a Docker Container\n.", 
            "title": "Deploy to App Service"
        }, 
        {
            "location": "/template-appservice/#what-is-azure-app-service", 
            "text": "The Azure App Service allows you to quickly build, deploy, and scale enterprise-grade web, mobile, and API apps running on any platform whilst meeting rigorous performance, scalability, security and compliance requirements using a fully-managed platform to perform infrastructure maintenance.  It comes in a number of pricing plans, including a free option and has options for scale-up, scale-out, turn-key authentication as well as powerful monitoring capabilities. It is compatible with many runtimes and includes excellent support for both .NET Framework and .NET Core.", 
            "title": "What is Azure App Service?"
        }, 
        {
            "location": "/template-appservice/#deployment-steps", 
            "text": "In order to deploy your SAFE application to the App Service, you must have first created an  Azure Account , selected a  Subscription ID  and created an associated  App Registration .", 
            "title": "Deployment Steps"
        }, 
        {
            "location": "/template-appservice/#custom-fake-build-tasks", 
            "text": "The Azure variant of the SAFE template adds the following extra build stages:   Bundle  - Runs after the standard Build step. It combines the outputs of the Client and Server application into a single folder.  ArmTemplate  - Deploys an Azure Resource Manager (ARM) template containing an entire environment as required by the SAFE application.  AppService  - Zips up the bundled folder and deploys it into the created environment.    There is a known issue that currently the FAKE script may sometimes fail the first time you run it with  this error . If this occurs, simply open the FAKE script in your favourite editor, add a new line anywhere in the script, save and re-run. We're looking to fix this as soon as possible!", 
            "title": "Custom FAKE build tasks"
        }, 
        {
            "location": "/template-appservice/#what-is-an-arm-template", 
            "text": "An ARM template is a declarative JSON file which contains the details of the Azure resources you require in your environment. This might include a web application, database, VM and messaging service - essentially any service supported by Azure. ARM templates are smart, in that you can repeatedly deploy them over an existing environment and only the newly added elements in the template will be applied onto the environment - perfect for a CI / CD approach. This also allows you to create entire dev / test environments from scratch within just a few minutes. The ARM template that comes with the SAFE template includes everything you need for a complete deployment to Azure from a clean state.", 
            "title": "What is an ARM template?"
        }, 
        {
            "location": "/template-appservice/#build-arguments", 
            "text": "Deploying your application through FAKE is relatively simple. Use the following command:  fake run build.fsx --target appservice\n    -e subscriptionId= subId \n    -e clientId= clientId \n    -e environment= environment  (optional)\n    -e location= location        (optional)\n    -e pricingTier= pricingTier  (optional)  where:   subscriptionId  is an Azure Subscription ID.  clientId  is the Application ID of an Azure App Registration.  environment  is an optional environment name that will be appended to all Azure resources created, which allows you to create entire dev / test environments quickly and easily. This defaults to a random GUID.  location  is the Azure data center location you wish to use. There are currently over 30 different data centers worldwide. This defaults to  westeurope ; the full list can be viewed  here . The location must be supplied in lower case and without spaces.  pricingTier  is the pricing tier of the app service that hosts your SAFE app. This defaults to F1 (free); the full list can be viewed  here .   Note that you can also modify the FAKE script and embed both the  subscriptionId  and  clientId  values directly in the script and commit into source control. This is completely safe to do as the Client ID is not sufficient on its own to authenticate into Azure (see below).", 
            "title": "Build arguments"
        }, 
        {
            "location": "/template-appservice/#interactive-deployment", 
            "text": "When running the build script, you will need to interactively authenticate with Azure in order to deploy the ARM template. During the FAKE script, you will see the following midway through the build cycle:   Navigating to that URL will request you to input the code shown above:   Finally, you will be prompted sign into Azure using your normal user account. After a short delay, the FAKE script will continue.    Note: If you're getting  FileNotFoundException  for  Microsoft.Rest.ClientRuntime.Azure , try editing and rerunning FAKE script ( see details ).", 
            "title": "Interactive deployment"
        }, 
        {
            "location": "/template-appservice/#creating-a-fully-automated-deployment", 
            "text": "You can also elect to implement a fully-automated (non-interactive) deployment model, ideal for Continuous Deployment (CD) scenarios through tools such as AppVeyor and Visual Studio Team Services, using an  Azure Active Directory Application . In this model, in addition to a SubscriptionID and Client ID, you also supply a Tenant ID and an Application Secret into the FAKE script to deploy your ARM resources; these identities should normally be secured and supplied into your FAKE script as arguments rather than committed into source control.", 
            "title": "Creating a fully automated deployment"
        }, 
        {
            "location": "/template-appservice/#viewing-the-deployed-safe-application", 
            "text": "Once the deployment is complete, you can log into the Azure Portal and see your environment being created.   Log into the Azure Portal.  Navigate to the Resource Groups blade and locate the newly-created group. Its name will be  safe- environment  e.g.  safe-helloworld .  Navigate to the App Service entry shown in the group following the convention  safe- environment -web .  Hit Browse from the new App Service blade that appears.  Your application will be shown in the browser running on a url following the convention  https://safe- environment -web.azurewebsites.net/ .   You can also  deploy to a Docker Container .", 
            "title": "Viewing the deployed SAFE application"
        }, 
        {
            "location": "/template-azure-ai/", 
            "text": "What is Application Insights?\n\n\nApplication Insights (AI) is an extensible Application Performance Management (APM) service for web developers on multiple platforms. You can use it to monitor your live web application; it will automatically detect performance anomalies. It includes powerful analytics tools to help you diagnose issues and to understand what users actually do with your app. It's designed to help you continuously improve performance and usability. Features of AI include:\n\n\n\n\nRequest tracking\n: monitoring every request, timing and response, with full correlation of operations within a request.\n\n\nDependency tracking\n: understand calls to third-party dependencies e.g. databases, web services etc.\n\n\nFailures\n: Understand which failures are occurring on your site, how often and with full stack traces.\n\n\nUser behaviours\n: Understand user flows such as funnels and retention.\n\n\nCustom Events and Metrics\n: You can easily create arbitrary metrics and events using the AI SDK for tracing and reporting.\n\n\nReporting Capabilities\n: Either use AI's built-in query language to create reports, or automatically export all data into a Storage Account for offline analytics.\n\n\n\n\nBasics of working with AI\n\n\nAI will automatically activate when you start running your SAFE application. You can locate your AI instance directly from within your SAFE Resource Group in the Azure Portal, or from the \"Application Insights\" link in the SAFE App Service.\n\n\n\n\nFrom your AI dashboard, you can drill down to trace all server requests:\n\n\n\n\nYou can then drill into any specific request, such as the \napi/init\n route shown above, in order to see individual requests.\n\n\n\n\nFrom here, you can even track further into any individual call. AI has many more features, so it's worth reading the \nextensive documentation\n on the Azure website.\n\n\nHow do SAFE apps integrate with AI?\n\n\nAlthough AI supports monitoring for both client \nand\n server, at the current time, the SAFE template only supports the server mode (although you can add support for client events yourself). Server-side support includes:\n\n\n\n\nSupport in the bundled ARM template to create a free AI instance along with your web application.\n\n\nAutomatic configuration of your web application with connection details to the created AI instance.\n\n\nApplication support for activating AI in code for e.g. custom events and metrics.\n\n\n\n\nAI integration is provided out-of-the-box in the template, since Giraffe uses the standard .NET Core Application Insights SDK in order to communicate with the AI service. It uses the standard AI middleware support for ASP .NET Core, which provides complete tracking of requests, dependencies, errors and live streaming.", 
            "title": "Application Insights Integration"
        }, 
        {
            "location": "/template-azure-ai/#what-is-application-insights", 
            "text": "Application Insights (AI) is an extensible Application Performance Management (APM) service for web developers on multiple platforms. You can use it to monitor your live web application; it will automatically detect performance anomalies. It includes powerful analytics tools to help you diagnose issues and to understand what users actually do with your app. It's designed to help you continuously improve performance and usability. Features of AI include:   Request tracking : monitoring every request, timing and response, with full correlation of operations within a request.  Dependency tracking : understand calls to third-party dependencies e.g. databases, web services etc.  Failures : Understand which failures are occurring on your site, how often and with full stack traces.  User behaviours : Understand user flows such as funnels and retention.  Custom Events and Metrics : You can easily create arbitrary metrics and events using the AI SDK for tracing and reporting.  Reporting Capabilities : Either use AI's built-in query language to create reports, or automatically export all data into a Storage Account for offline analytics.", 
            "title": "What is Application Insights?"
        }, 
        {
            "location": "/template-azure-ai/#basics-of-working-with-ai", 
            "text": "AI will automatically activate when you start running your SAFE application. You can locate your AI instance directly from within your SAFE Resource Group in the Azure Portal, or from the \"Application Insights\" link in the SAFE App Service.   From your AI dashboard, you can drill down to trace all server requests:   You can then drill into any specific request, such as the  api/init  route shown above, in order to see individual requests.   From here, you can even track further into any individual call. AI has many more features, so it's worth reading the  extensive documentation  on the Azure website.", 
            "title": "Basics of working with AI"
        }, 
        {
            "location": "/template-azure-ai/#how-do-safe-apps-integrate-with-ai", 
            "text": "Although AI supports monitoring for both client  and  server, at the current time, the SAFE template only supports the server mode (although you can add support for client events yourself). Server-side support includes:   Support in the bundled ARM template to create a free AI instance along with your web application.  Automatic configuration of your web application with connection details to the created AI instance.  Application support for activating AI in code for e.g. custom events and metrics.   AI integration is provided out-of-the-box in the template, since Giraffe uses the standard .NET Core Application Insights SDK in order to communicate with the AI service. It uses the standard AI middleware support for ASP .NET Core, which provides complete tracking of requests, dependencies, errors and live streaming.", 
            "title": "How do SAFE apps integrate with AI?"
        }, 
        {
            "location": "/template-azure-registration/", 
            "text": "In order to deploy applications to Azure from the FAKE script created by the SAFE template, you first need to create an Azure account and create an App Registration which allows remote deployments as a one-off task. This section explains how to do this.\n\n\nCreating an Azure Account\n\n\nYou'll need to register for an Azure account. This can be achieved quickly and easily at \nhttps://azure.microsoft.com\n. New users are afforded a number of services for free for an entire year, including Azure SQL, Storage and VMs etc.\n\n\nSelecting a Subscription\n\n\nOnce you have created your account, you'll need to make a note of the Azure Subscription ID that you will deploy your SAFE applications into.\n\n\n\n\nLog in to your \nAzure Portal\n.\n\n\nSelect All Services on the left-menu menu and locate \nSubscriptions\n in the blade on the right.\n\n\n\nMake a note of the \nSubscription ID\n of the subscription that you wish to deploy your application into. If you just created your Azure account, you'll most likely have a single subscription in the list.\n\n\n\n\n\nCreating an App Registration\n\n\nYou now need to create an \"App Registration\" in your Azure Active Directory. This registration allows you to deploy an entire environment directly into Azure, complete with the deployed application, directly from a FAKE script.\n\n\n\n\nNavigate to the \nAzure Active Directory\n blade in the Portal.\n\n\nSelect \nApp registrations\n from the menu in the blade.\n\n\nSelect \nNew application registration\n.\n\n\n\nEnter the \nName\n of your application as any name e.g \nSAFE Deploy\n\n\nSet the \nApplication type\n as \nNative\n.\n\n\nSet the Redirect URI as any URI e.g \nhttp://safe-stack.github.io/\n\n\nHit Create.\n\n\nMake a note of the \nApplication ID\n on the blade.\n\n\n\nChoose \nSettings\n from the top menu.\n\n\nChoose \nRequired Permissions\n from the Settings blade.\n\n\nChoose \nAdd\n from the top menu of the Required Permissions blade.\n\n\nChoose \nSelect an API\n from the Add API Access blade.\n\n\nChoose \nWindows Azure Service Management API\n and hit \nSelect\n.\n\n\nCheck \nAccess Azure Service Management as organization users (preview)\n and hit \nSelect\n.\n\n\nHit \nDone\n from the Add API Access blade.\n\n\n\n\nCongratulations - you're now ready to use the SAFE FAKE template to perform remote deployments.", 
            "title": "Registering with Azure"
        }, 
        {
            "location": "/template-azure-registration/#creating-an-azure-account", 
            "text": "You'll need to register for an Azure account. This can be achieved quickly and easily at  https://azure.microsoft.com . New users are afforded a number of services for free for an entire year, including Azure SQL, Storage and VMs etc.", 
            "title": "Creating an Azure Account"
        }, 
        {
            "location": "/template-azure-registration/#selecting-a-subscription", 
            "text": "Once you have created your account, you'll need to make a note of the Azure Subscription ID that you will deploy your SAFE applications into.   Log in to your  Azure Portal .  Select All Services on the left-menu menu and locate  Subscriptions  in the blade on the right.  Make a note of the  Subscription ID  of the subscription that you wish to deploy your application into. If you just created your Azure account, you'll most likely have a single subscription in the list.", 
            "title": "Selecting a Subscription"
        }, 
        {
            "location": "/template-azure-registration/#creating-an-app-registration", 
            "text": "You now need to create an \"App Registration\" in your Azure Active Directory. This registration allows you to deploy an entire environment directly into Azure, complete with the deployed application, directly from a FAKE script.   Navigate to the  Azure Active Directory  blade in the Portal.  Select  App registrations  from the menu in the blade.  Select  New application registration .  Enter the  Name  of your application as any name e.g  SAFE Deploy  Set the  Application type  as  Native .  Set the Redirect URI as any URI e.g  http://safe-stack.github.io/  Hit Create.  Make a note of the  Application ID  on the blade.  Choose  Settings  from the top menu.  Choose  Required Permissions  from the Settings blade.  Choose  Add  from the top menu of the Required Permissions blade.  Choose  Select an API  from the Add API Access blade.  Choose  Windows Azure Service Management API  and hit  Select .  Check  Access Azure Service Management as organization users (preview)  and hit  Select .  Hit  Done  from the Add API Access blade.   Congratulations - you're now ready to use the SAFE FAKE template to perform remote deployments.", 
            "title": "Creating an App Registration"
        }, 
        {
            "location": "/feature-clientserver/", 
            "text": "One of the most powerful features of SAFE is the ability to seamlessly share \ndata\n, \ntypes\n and \ncode\n across client and server.\n\n\nSharing Types\n\n\nSharing your domain types and contracts between client and server is extremely simple. Thanks to Fable's excellent F# transpilation into Javascript, you can use all standard F# language features such as Records, Tuples and Discriminated Unions without worry. To share types across both your client and server project, first create a file in your repository called e.g \nShared.fs\n.\n\n\n\nThen, create types in the file as needed e.g\n\n\ntype Customer = { Name : string }\n\n\n\n\nReference this file to your server project. You can now reference those types in the server.\n\n\nProject Sdk=\nMicrosoft.NET.Sdk\n\n    ...\n    \nItemGroup\n\n        \nCompile Include=\n../Shared/Shared.fs\n /\n\n    \n/ItemGroup\n\n    ...\n\n/Project\n\n\n\n\n\nFinally, reference this file to your client project (as above). You can now reference those types in the client; types will be compiled into Javascript types and seamlessly translated for you.\n\n\nSharing Code\n\n\nYou can also share code using the same mechanism. This is extremely useful for e.g shared validation or business logic that needs to occur on both client and server.\n\n\nFable will translate your functions into native Javascript, and will even translate many calls to the .NET base class library into corresponding Javascript! This allows you to compile your domain model and domain logic to many many different targets including:\n\n\n\n\nASP.NET Core (via Saturn)\n\n\nAzure Functions\n\n\nJavascript that runs in the browser\n\n\nJavascript that runs on mobile devices with \nReact Native\n.\n\n\nRaspberry Pi (via .NET Core)\n\n\n\n\nYou can read more about this \non the Fable website\n.\n\n\nSharing Data\n\n\nSharing data can be achieved in two main ways in SAFE: through the \nSaturn\n API directly, or via the \nFable.Remoting\n library.\n\n\nSharing data with Saturn\n\n\nSharing data using Saturn is very simple. Start by creating a function in your server that returns some data:\n\n\nlet loadCustomersFromDb() =\n    [ { Name = \nJoe Bloggs\n } ]\n\n\n\n\nNext, create a method which returns the data as JSON within Giraffe's HTTP context.\n\n\n/// Returns the results of loadCustomersFromDb as JSON.\nlet getCustomers next ctx =\n    json (loadCustomersFromDb()) next ctx\n\n\n\n\nYou can opt to combine both of the above functions into one, depending on your preferences, but it's often good practice to separate your data access from serving data in HTTP endpoints.\n\n\nAlso note the \nnext\n and \nctx\n arguments. These are used by Giraffe as part of its \nHTTP pipeline\n and are required by the \njson\n function.\n\n\nNow expose the api method using \nSaturn's\n \nscope\n construct and add the scope to your overall application scope:\n\n\nlet myApis = scope {\n    get \n/api/customers/\n getCustomers\n}\n\n\n\n\nFor simple endpoints you may elect to embed the API call directly in the scope (and use partial application to omit the \nnext\n and \nctx\n arguments):\n\n\nlet myApis = scope {\n    get \n/api/customers/\n (json (loadCustomersFromDb()))\n}\n\n\n\n\nFinally, call the endpoint from your client application.\n\n\npromise {    \n    let! customers = Fetch.fetchAs\nCustomer array\n (sprintf \napi/customers\n) []\n    // do more with customers here...\n}\n\n\n\n\nNote the use of the \npromise { }\n computation expression. This behaves similarly to \nasync { }\n blocks that you might already know, whilst the \nfetchAs\n function automatically deserializes the JSON back into a \nCustomer\n array.\n\n\nTurning on Fable's JSON Converter\n\n\nBy default, serialization between Fable and Giraffe \nis not compatible\n. In order to fix this, you must replace the JSON converter in Giraffe with Fable's own \nIJsonSerializer\n.\n\n\nIf you are using the \nSAFE Template\n, this will automatically be done for you - see the \nconfig\n function in \nServer.fs\n.\n\n\nSharing data using Fable.Remoting\n\n\nAs an alternative to raw HTTP, you can also use the \nFable.Remoting\n library, which provides an RPC-style mechanism for calling server endpoints.\n\n\nIn our case, instead of creating a \nscope { }\n on the server and using \nfetch\n on the client, you create a simple \nprotocol\n which contains methods exposed by the server:\n\n\ntype ICustomer = {\n    customers : unit -\n Async\nCustomer array\n\n}\n\nlet server : ICustomer = {\n    customers = fun () -\n async { return loadCustomersFromDb() }\n}\n\n\n\n\nOn the client, you need only create a proxy for the protocol and then can call methods on it directly.\n\n\nasync {\n    let server = Proxy.remoting\nICustomer\n {()}\n    let! customers = server.customers()\n    /// ...\n}\n\n\n\n\nNotice here, there is no need to create routes, or worry about HTTP verbs, or even involve yourself with the Giraffe pipeline.\n\n\nWhen should I use raw HTTP vs Fable Remoting?\n\n\nFable Remoting provides an excellent way to quickly get up and running with the SAFE stack. You can rapidly create contracts between client / server and have guaranteed contracts between both client and server. However, note that Fable Remoting is not designed for use as an \"open\" API for consumption by multiple client. It also forces all HTTP traffic to be delivered as a POST, which cannot be cached by the browser. If you're using a \"closed\" app without exposing an API to other consumers, and do not need close control of the HTTP channel, consider using Fable.Remoting.\n\n\nAlternatively, the raw HTTP model provided by Saturn with \nscope { }\n requires you to construct routes manually and does not guarantee that the client and endpoint have the same contract (you have to specify the same type on both sides yourself). However, Saturn gives you total control over the routing and verbs used. If you have a public API that is exposed not just to your own application but to third-parties, or you need more fine grained control over your routes and data, you should use this approach.\n\n\nAlternatively, consider using a combination of both Remoting and Saturn endpoints - Remoting for those that are used \"internally\" by your application, and Saturn for those exposed to external callers.\n\n\n\n\n\n\n\n\n\n\nFable.Remoting\n\n\nRaw HTTP\n\n\n\n\n\n\n\n\n\n\nClient / Server support\n\n\nVery easy\n\n\nEasy\n\n\n\n\n\n\n\"Open\" API?\n\n\nNo\n\n\nYes\n\n\n\n\n\n\nHTTP Verbs?\n\n\nPOST\n\n\nFully Configurable\n\n\n\n\n\n\nPipeline Control?\n\n\nLimited\n\n\nFull", 
            "title": "Client/Server communication"
        }, 
        {
            "location": "/feature-clientserver/#sharing-types", 
            "text": "Sharing your domain types and contracts between client and server is extremely simple. Thanks to Fable's excellent F# transpilation into Javascript, you can use all standard F# language features such as Records, Tuples and Discriminated Unions without worry. To share types across both your client and server project, first create a file in your repository called e.g  Shared.fs .  Then, create types in the file as needed e.g  type Customer = { Name : string }  Reference this file to your server project. You can now reference those types in the server.  Project Sdk= Microsoft.NET.Sdk \n    ...\n     ItemGroup \n         Compile Include= ../Shared/Shared.fs  / \n     /ItemGroup \n    ... /Project   Finally, reference this file to your client project (as above). You can now reference those types in the client; types will be compiled into Javascript types and seamlessly translated for you.", 
            "title": "Sharing Types"
        }, 
        {
            "location": "/feature-clientserver/#sharing-code", 
            "text": "You can also share code using the same mechanism. This is extremely useful for e.g shared validation or business logic that needs to occur on both client and server.  Fable will translate your functions into native Javascript, and will even translate many calls to the .NET base class library into corresponding Javascript! This allows you to compile your domain model and domain logic to many many different targets including:   ASP.NET Core (via Saturn)  Azure Functions  Javascript that runs in the browser  Javascript that runs on mobile devices with  React Native .  Raspberry Pi (via .NET Core)   You can read more about this  on the Fable website .", 
            "title": "Sharing Code"
        }, 
        {
            "location": "/feature-clientserver/#sharing-data", 
            "text": "Sharing data can be achieved in two main ways in SAFE: through the  Saturn  API directly, or via the  Fable.Remoting  library.", 
            "title": "Sharing Data"
        }, 
        {
            "location": "/feature-clientserver/#sharing-data-with-saturn", 
            "text": "Sharing data using Saturn is very simple. Start by creating a function in your server that returns some data:  let loadCustomersFromDb() =\n    [ { Name =  Joe Bloggs  } ]  Next, create a method which returns the data as JSON within Giraffe's HTTP context.  /// Returns the results of loadCustomersFromDb as JSON.\nlet getCustomers next ctx =\n    json (loadCustomersFromDb()) next ctx  You can opt to combine both of the above functions into one, depending on your preferences, but it's often good practice to separate your data access from serving data in HTTP endpoints.  Also note the  next  and  ctx  arguments. These are used by Giraffe as part of its  HTTP pipeline  and are required by the  json  function.  Now expose the api method using  Saturn's   scope  construct and add the scope to your overall application scope:  let myApis = scope {\n    get  /api/customers/  getCustomers\n}  For simple endpoints you may elect to embed the API call directly in the scope (and use partial application to omit the  next  and  ctx  arguments):  let myApis = scope {\n    get  /api/customers/  (json (loadCustomersFromDb()))\n}  Finally, call the endpoint from your client application.  promise {    \n    let! customers = Fetch.fetchAs Customer array  (sprintf  api/customers ) []\n    // do more with customers here...\n}  Note the use of the  promise { }  computation expression. This behaves similarly to  async { }  blocks that you might already know, whilst the  fetchAs  function automatically deserializes the JSON back into a  Customer  array.", 
            "title": "Sharing data with Saturn"
        }, 
        {
            "location": "/feature-clientserver/#turning-on-fables-json-converter", 
            "text": "By default, serialization between Fable and Giraffe  is not compatible . In order to fix this, you must replace the JSON converter in Giraffe with Fable's own  IJsonSerializer .  If you are using the  SAFE Template , this will automatically be done for you - see the  config  function in  Server.fs .", 
            "title": "Turning on Fable's JSON Converter"
        }, 
        {
            "location": "/feature-clientserver/#sharing-data-using-fableremoting", 
            "text": "As an alternative to raw HTTP, you can also use the  Fable.Remoting  library, which provides an RPC-style mechanism for calling server endpoints.  In our case, instead of creating a  scope { }  on the server and using  fetch  on the client, you create a simple  protocol  which contains methods exposed by the server:  type ICustomer = {\n    customers : unit -  Async Customer array \n}\n\nlet server : ICustomer = {\n    customers = fun () -  async { return loadCustomersFromDb() }\n}  On the client, you need only create a proxy for the protocol and then can call methods on it directly.  async {\n    let server = Proxy.remoting ICustomer  {()}\n    let! customers = server.customers()\n    /// ...\n}  Notice here, there is no need to create routes, or worry about HTTP verbs, or even involve yourself with the Giraffe pipeline.", 
            "title": "Sharing data using Fable.Remoting"
        }, 
        {
            "location": "/feature-clientserver/#when-should-i-use-raw-http-vs-fable-remoting", 
            "text": "Fable Remoting provides an excellent way to quickly get up and running with the SAFE stack. You can rapidly create contracts between client / server and have guaranteed contracts between both client and server. However, note that Fable Remoting is not designed for use as an \"open\" API for consumption by multiple client. It also forces all HTTP traffic to be delivered as a POST, which cannot be cached by the browser. If you're using a \"closed\" app without exposing an API to other consumers, and do not need close control of the HTTP channel, consider using Fable.Remoting.  Alternatively, the raw HTTP model provided by Saturn with  scope { }  requires you to construct routes manually and does not guarantee that the client and endpoint have the same contract (you have to specify the same type on both sides yourself). However, Saturn gives you total control over the routing and verbs used. If you have a public API that is exposed not just to your own application but to third-parties, or you need more fine grained control over your routes and data, you should use this approach.  Alternatively, consider using a combination of both Remoting and Saturn endpoints - Remoting for those that are used \"internally\" by your application, and Saturn for those exposed to external callers.      Fable.Remoting  Raw HTTP      Client / Server support  Very easy  Easy    \"Open\" API?  No  Yes    HTTP Verbs?  POST  Fully Configurable    Pipeline Control?  Limited  Full", 
            "title": "When should I use raw HTTP vs Fable Remoting?"
        }, 
        {
            "location": "/feature-ssr/", 
            "text": "Server-Side Rendering (SSR) means that some parts of your application code can run on both the server and the client.\nFor \nReact\n this means that you can render your components directly to HTML on the server side (usually via a \nnode.js server\n), which allows for better search engine optimization (SEO) and gives a faster initial response, especially on mobile devices.\n\n\nThe browser typically receives a static HTML site and starts updating the UI immediately;\nReact's bundle code will be downloaded asynchronously and when it completes, the client-side JavaScript will take over via \nReact's hydrate\n functionality. In the JavaScript ecosystem this is also as known as an \"isomorphic\" or \"universal\" app.\n\n\nWhy use SSR?\n\n\nPros\n\n\n\n\nBetter SEO support, as web crawlers will directly see the fully rendered HTML page.\n\n\nFaster time-to-content, especially on slow internet connections or devices.\n\n\n\n\nCons\n\n\n\n\nSome development constraints. Browser-specific code requires some compiler directives to be ignored when running on the server.\n\n\nIncreased complexity of build and deployment processes.\n\n\nIncreased server-side load.\n\n\n\n\nSSR on SAFE\n\n\nIn SAFE, SSR can be done using \nfable-react\n. Its approach is a little different from those you might have seen in the JavaScript ecosystem, as it takes a purely F# approach: you render your \nElmish\n views directly on .NET Core, with all the benefits of the .NET Core runtime.\n\n\nFurther reading\n\n\n\n\nMore details can be found in the \nSSR tutorial\n.\n\n\nThe \nSAFE-BookStore\n sample project uses SSR.", 
            "title": "Server Side Rendering"
        }, 
        {
            "location": "/feature-ssr/#why-use-ssr", 
            "text": "", 
            "title": "Why use SSR?"
        }, 
        {
            "location": "/feature-ssr/#pros", 
            "text": "Better SEO support, as web crawlers will directly see the fully rendered HTML page.  Faster time-to-content, especially on slow internet connections or devices.", 
            "title": "Pros"
        }, 
        {
            "location": "/feature-ssr/#cons", 
            "text": "Some development constraints. Browser-specific code requires some compiler directives to be ignored when running on the server.  Increased complexity of build and deployment processes.  Increased server-side load.", 
            "title": "Cons"
        }, 
        {
            "location": "/feature-ssr/#ssr-on-safe", 
            "text": "In SAFE, SSR can be done using  fable-react . Its approach is a little different from those you might have seen in the JavaScript ecosystem, as it takes a purely F# approach: you render your  Elmish  views directly on .NET Core, with all the benefits of the .NET Core runtime.", 
            "title": "SSR on SAFE"
        }, 
        {
            "location": "/feature-ssr/#further-reading", 
            "text": "More details can be found in the  SSR tutorial .  The  SAFE-BookStore  sample project uses SSR.", 
            "title": "Further reading"
        }, 
        {
            "location": "/feature-hmr/", 
            "text": "Hot Module Replacement (HMR) allows to update the UI of an application while it is running, without a full reload. In SAFE stack apps, this can dramatically speed up the development for web and mobile GUIs, since there is no need to \"stop\" and \"reload\" and application. Instead, you can make changes to your views and have them immediately update in the browser, without the need to restart the application.\n\n\nHow does it work?\n\n\nIn case of web development, the \nwebpack\n development server will automatically refresh the changed parts of your \nelmish\n views whenever you save a file. Alternatively, in the case of mobile app development, this is achieved through \nReact Native\n's own bundler.\n\n\nWhy does it work so well with SAFE?\n\n\nSince SAFE uses the Model-View-Update architecture with immutable models, the application state only changes when a message is processed; this fits the HMR model very nicely. Here's an example of HMR in action to change the input of a textbox to automatically convert the input to upper case.\n\n\n\n\nFurther reading\n\n\n\n\nHot Module Replacement\n via webpack\n\n\nIntroducing Hot Reloading\n in React Native", 
            "title": "Hot Module Replacement"
        }, 
        {
            "location": "/feature-hmr/#how-does-it-work", 
            "text": "In case of web development, the  webpack  development server will automatically refresh the changed parts of your  elmish  views whenever you save a file. Alternatively, in the case of mobile app development, this is achieved through  React Native 's own bundler.", 
            "title": "How does it work?"
        }, 
        {
            "location": "/feature-hmr/#why-does-it-work-so-well-with-safe", 
            "text": "Since SAFE uses the Model-View-Update architecture with immutable models, the application state only changes when a message is processed; this fits the HMR model very nicely. Here's an example of HMR in action to change the input of a textbox to automatically convert the input to upper case.", 
            "title": "Why does it work so well with SAFE?"
        }, 
        {
            "location": "/feature-hmr/#further-reading", 
            "text": "Hot Module Replacement  via webpack  Introducing Hot Reloading  in React Native", 
            "title": "Further reading"
        }, 
        {
            "location": "/faq-server/", 
            "text": "Server-side options in SAFE\n\n\nThe \nSAFE template\n comes with two alternative web server technologies out of the box:\n\n\n\n\nSaturn\n - A simple, flexible F# abstraction layer that runs on top of Giraffe that enables both MVC- and Web API-style services. \n\n\nGiraffe\n - A flexible F# framework for creating web-enabled applications. Giraffe runs on top of ASP .NET Core and the Kestrel server.\n\n\n\n\n\n\nBoth Saturn and Giraffe are \nfully ASP .NET Core compatible\n and offer \nF#-first\n programming experiences - there's no need to wrap your DTOs in \n[\nCLIMutable\n]\n or inherit from base classes to get up and running.\n\n\nWhy Saturn?\n\n\n Saturn is the default and recommended web server in SAFE\n.\n\n\nSaturn (and Giraffe) runs on top of ASP .NET Core, which comes with an extremely high-performance server that is fully supported by Microsoft, has a huge community of developers and has excellent integration into cloud services such as Microsoft Azure and Amazon Web Services.\n\n\nIn addition, whilst the Giraffe programming is extremely composable and fully functional-first, Saturn allows you to take advantage of abstractions such as \napplication { }\n, \nscope { }\n and \ncontroller { }\n which are not only extremely simple to use but will also be familiar to developers from other (non-.NET) web programming models.\n\n\nIt's important to note that Saturn lives \"on top\" of Giraffe; you can think of Saturn as a layer of added goodness which provide a set of new higher-level abstractions which delegate down to Giraffe's HTTP Handler. And since Saturn's abstractions are all \noptional\n, you can always fall back directly to the lower-level Giraffe model if required.\n\n\nComing from Suave?\n\n\nGiraffe's HTTP Handler is a very similar abstraction to that of the Suave web server, which means that you can easily migrate over to Giraffe (and Saturn) and quickly start to benefit from the features that ASP .NET, Giraffe and Saturn all provide.", 
            "title": "Choosing your web server"
        }, 
        {
            "location": "/faq-server/#server-side-options-in-safe", 
            "text": "The  SAFE template  comes with two alternative web server technologies out of the box:   Saturn  - A simple, flexible F# abstraction layer that runs on top of Giraffe that enables both MVC- and Web API-style services.   Giraffe  - A flexible F# framework for creating web-enabled applications. Giraffe runs on top of ASP .NET Core and the Kestrel server.    Both Saturn and Giraffe are  fully ASP .NET Core compatible  and offer  F#-first  programming experiences - there's no need to wrap your DTOs in  [ CLIMutable ]  or inherit from base classes to get up and running.", 
            "title": "Server-side options in SAFE"
        }, 
        {
            "location": "/faq-server/#why-saturn", 
            "text": "Saturn is the default and recommended web server in SAFE .  Saturn (and Giraffe) runs on top of ASP .NET Core, which comes with an extremely high-performance server that is fully supported by Microsoft, has a huge community of developers and has excellent integration into cloud services such as Microsoft Azure and Amazon Web Services.  In addition, whilst the Giraffe programming is extremely composable and fully functional-first, Saturn allows you to take advantage of abstractions such as  application { } ,  scope { }  and  controller { }  which are not only extremely simple to use but will also be familiar to developers from other (non-.NET) web programming models.  It's important to note that Saturn lives \"on top\" of Giraffe; you can think of Saturn as a layer of added goodness which provide a set of new higher-level abstractions which delegate down to Giraffe's HTTP Handler. And since Saturn's abstractions are all  optional , you can always fall back directly to the lower-level Giraffe model if required.", 
            "title": "Why Saturn?"
        }, 
        {
            "location": "/faq-server/#coming-from-suave", 
            "text": "Giraffe's HTTP Handler is a very similar abstraction to that of the Suave web server, which means that you can easily migrate over to Giraffe (and Saturn) and quickly start to benefit from the features that ASP .NET, Giraffe and Saturn all provide.", 
            "title": "Coming from Suave?"
        }, 
        {
            "location": "/faq-build/", 
            "text": "Support for moving from development to production with SAFE applications is included \"out of the box\" when using e.g. \nAzure\n or \nDocker\n deployment options. Nonetheless, this page explains the key differences that you should be aware of between running SAFE applications in development and production.\n\n\nDeveloping SAFE applications\n\n\nThe SAFE template is geared up towards a streamlined development process. Firstly, it contains a \nFAKE build script\n which you can use this to quickly download dependencies, as well as build and run both the client and server on your machine.\n\n\nThe development process uses \ntwo web servers\n running in tandem:\n\n\n\n\nThe \"back-end\" .NET web server which hosts your API endpoints and other server-generated content. This uses Kestrel on ASP .NET out of the box (although you can opt for \nother options\n).\n\n\nA \"front-end\" web server which hosts your Fable application. The SAFE template uses the \nWebpack Dev Server\n for this.\n\n\n\n\n\n\nThe backend build makes use of \ndotnet watch\n to allow you to make changes to your server-side application and have the server automatically restart with the latest changes. Since your back-end applications will typically be stateless, this permits a rapid development workflow.\n\n\nOn the client side, your code is compiled using webpack. This provides many benefits for working with javascript, such as minification and bundling, as well as \nhot module replacement\n, a feature made possible when using the webpack dev server. This means that you can continually make changes to your client application code and can rapidly see the results reflected in your browser, without the need to fully reload the application.\n\n\nWebpack Dev Server\n\n\nIt's important to note that the webpack dev server is configured to automatically route traffic intended for \napi/*\n routes to the back-end web server. This \nsimulates\n how a SAFE application might work in a production environment, with both client and server assets served from a single web server. This also allows you to not worry about ports and hosts for your backend server in your client code, or \nCORS\n issues. You can find out more about the configuration of the webpack dev server in SAFE \nhere\n.\n\n\nRunning SAFE applications in production\n\n\nIn a production environment, you won't typically use the webpack dev server. Instead, it's more common to use webpack as a one-off compiler step to create your bundled javascript from your Fable app (plus dependencies), and then deploy this along with your back-end web server which also hosts that content directly. For example, you can use Saturn to host the static content required by the application e.g. HTML, JS and CSS files etc. as well as your back-end APIs. This fits very well with standard CI / CD processes, as a build step in your FAKE script or VSTS / AppVeyor / Travis step etc.\n\n\nBoth the \nAzure\n and \nDocker\n configuration options will do this automatically.\n\n\n\n\nClient asset hosting alternatives\n\n\nRather than hosting your client-side content and application inside your web server, you can opt to host your static content from some other service that supports hosting of HTTP content, such as Azure Blobs, or a content hosting service. In such a case, you'll need to consider how to route traffic to your back-end API from your client application (as they are hosted on different domains), as well as handle any potential CORS issues.", 
            "title": "Moving from dev to prod"
        }, 
        {
            "location": "/faq-build/#developing-safe-applications", 
            "text": "The SAFE template is geared up towards a streamlined development process. Firstly, it contains a  FAKE build script  which you can use this to quickly download dependencies, as well as build and run both the client and server on your machine.  The development process uses  two web servers  running in tandem:   The \"back-end\" .NET web server which hosts your API endpoints and other server-generated content. This uses Kestrel on ASP .NET out of the box (although you can opt for  other options ).  A \"front-end\" web server which hosts your Fable application. The SAFE template uses the  Webpack Dev Server  for this.    The backend build makes use of  dotnet watch  to allow you to make changes to your server-side application and have the server automatically restart with the latest changes. Since your back-end applications will typically be stateless, this permits a rapid development workflow.  On the client side, your code is compiled using webpack. This provides many benefits for working with javascript, such as minification and bundling, as well as  hot module replacement , a feature made possible when using the webpack dev server. This means that you can continually make changes to your client application code and can rapidly see the results reflected in your browser, without the need to fully reload the application.", 
            "title": "Developing SAFE applications"
        }, 
        {
            "location": "/faq-build/#webpack-dev-server", 
            "text": "It's important to note that the webpack dev server is configured to automatically route traffic intended for  api/*  routes to the back-end web server. This  simulates  how a SAFE application might work in a production environment, with both client and server assets served from a single web server. This also allows you to not worry about ports and hosts for your backend server in your client code, or  CORS  issues. You can find out more about the configuration of the webpack dev server in SAFE  here .", 
            "title": "Webpack Dev Server"
        }, 
        {
            "location": "/faq-build/#running-safe-applications-in-production", 
            "text": "In a production environment, you won't typically use the webpack dev server. Instead, it's more common to use webpack as a one-off compiler step to create your bundled javascript from your Fable app (plus dependencies), and then deploy this along with your back-end web server which also hosts that content directly. For example, you can use Saturn to host the static content required by the application e.g. HTML, JS and CSS files etc. as well as your back-end APIs. This fits very well with standard CI / CD processes, as a build step in your FAKE script or VSTS / AppVeyor / Travis step etc.  Both the  Azure  and  Docker  configuration options will do this automatically.", 
            "title": "Running SAFE applications in production"
        }, 
        {
            "location": "/faq-build/#client-asset-hosting-alternatives", 
            "text": "Rather than hosting your client-side content and application inside your web server, you can opt to host your static content from some other service that supports hosting of HTTP content, such as Azure Blobs, or a content hosting service. In such a case, you'll need to consider how to route traffic to your back-end API from your client application (as they are hosted on different domains), as well as handle any potential CORS issues.", 
            "title": "Client asset hosting alternatives"
        }, 
        {
            "location": "/learning/", 
            "text": "This section contains useful repositories that allow you to learn more about the SAFE stack, at your own pace.\n\n\nTutorials\n\n\nSAFE Dojo\n\n\nThis dojo is a guided set of tasks designed to give you hands-on experience with the client and server components of the SAFE stack. You'll create server-side routes, client side UI and shared validation logic as you create a mashup application to provide details on UK locations.\n\n\nThe dojo takes around 90 minutes to complete if you have never worked with the stack before.\n\n\nSAFE Samples\n\n\nThe following example repositories (and more!) can be found in the official \nSAFE Stack\n organisational GitHub page.\n\n\nSAFE Todo List\n\n\nThe simplest Todo app: a client-server application written entirely in F# using Elmish on the client. Remoting for type-safe communication between the two.\n\n\nSAFE Bookstore\n\n\nThis sample demonstrates many of the useful features of a larger SAFE application, including login authentication using JWT tokens, automated deployment via Docker and SEO support with urls for pages. It also includes an example of using Azure Storage tables as a persistence store.\n\n\nSAFE ConfPlanner\n\n\nThis sample demonstrates how to build and share a complex domain model in SAFE across client and server, along with the use of websockets for a \"reactive\" UI support push notifications. It also demonstrates the use of F#'s flexible mailbox processors to implement an event-driven architecture.\n\n\nSAFE Search\n\n\nThis repository shows how to use Azure services to implement a SAFE application that supports searching over multiple data sources with support for find-ahead typing and throttling. The application uses a combination of Azure Search and Azure Storage Tables to construct a large search index that can rapidly find results in a number of ways.\n\n\nSAFE Chat\n\n\nThis application is a real-time chat application built on SAFE that uses the \nAKKA framework\n to manage actors that represent chat users, including Akka Streams and the Akkling F# library.\n\n\nSAFE Nightwatch\n\n\nThis application is a sample mobile application using the \nReact Native\n library, built on top of the SAFE stack. React Native permits a very similar programming when writing SAFE applications as browser applications, so the experience should be very familiar to you.\n\n\nVideos\n\n\n\n\nSAFE apps with F# web stack\n at F# Exchange 2018 (Tomasz Heimowski)\n\n\nModern app development with Fable and React Native\n at NDC Oslo 2017 (Steffen Forkmann)\n\n\n\n\nOther Resources\n\n\n\n\nThe Hanselminutes podcast: F# and the functional SAFE Stack\n with Krzysztof Cieslak\n\n\nIntroducing Fable.Remoting: Automated Type-Safe Client-Server Communication for Fable Apps\n\n\nLearning about the F# SAFE stack \n High level introduction to the SAFE stack by Scott Hanselman", 
            "title": "Learning Resources"
        }, 
        {
            "location": "/learning/#tutorials", 
            "text": "", 
            "title": "Tutorials"
        }, 
        {
            "location": "/learning/#safe-dojo", 
            "text": "This dojo is a guided set of tasks designed to give you hands-on experience with the client and server components of the SAFE stack. You'll create server-side routes, client side UI and shared validation logic as you create a mashup application to provide details on UK locations.  The dojo takes around 90 minutes to complete if you have never worked with the stack before.", 
            "title": "SAFE Dojo"
        }, 
        {
            "location": "/learning/#safe-samples", 
            "text": "The following example repositories (and more!) can be found in the official  SAFE Stack  organisational GitHub page.", 
            "title": "SAFE Samples"
        }, 
        {
            "location": "/learning/#safe-todo-list", 
            "text": "The simplest Todo app: a client-server application written entirely in F# using Elmish on the client. Remoting for type-safe communication between the two.", 
            "title": "SAFE Todo List"
        }, 
        {
            "location": "/learning/#safe-bookstore", 
            "text": "This sample demonstrates many of the useful features of a larger SAFE application, including login authentication using JWT tokens, automated deployment via Docker and SEO support with urls for pages. It also includes an example of using Azure Storage tables as a persistence store.", 
            "title": "SAFE Bookstore"
        }, 
        {
            "location": "/learning/#safe-confplanner", 
            "text": "This sample demonstrates how to build and share a complex domain model in SAFE across client and server, along with the use of websockets for a \"reactive\" UI support push notifications. It also demonstrates the use of F#'s flexible mailbox processors to implement an event-driven architecture.", 
            "title": "SAFE ConfPlanner"
        }, 
        {
            "location": "/learning/#safe-search", 
            "text": "This repository shows how to use Azure services to implement a SAFE application that supports searching over multiple data sources with support for find-ahead typing and throttling. The application uses a combination of Azure Search and Azure Storage Tables to construct a large search index that can rapidly find results in a number of ways.", 
            "title": "SAFE Search"
        }, 
        {
            "location": "/learning/#safe-chat", 
            "text": "This application is a real-time chat application built on SAFE that uses the  AKKA framework  to manage actors that represent chat users, including Akka Streams and the Akkling F# library.", 
            "title": "SAFE Chat"
        }, 
        {
            "location": "/learning/#safe-nightwatch", 
            "text": "This application is a sample mobile application using the  React Native  library, built on top of the SAFE stack. React Native permits a very similar programming when writing SAFE applications as browser applications, so the experience should be very familiar to you.", 
            "title": "SAFE Nightwatch"
        }, 
        {
            "location": "/learning/#videos", 
            "text": "SAFE apps with F# web stack  at F# Exchange 2018 (Tomasz Heimowski)  Modern app development with Fable and React Native  at NDC Oslo 2017 (Steffen Forkmann)", 
            "title": "Videos"
        }, 
        {
            "location": "/learning/#other-resources", 
            "text": "The Hanselminutes podcast: F# and the functional SAFE Stack  with Krzysztof Cieslak  Introducing Fable.Remoting: Automated Type-Safe Client-Server Communication for Fable Apps  Learning about the F# SAFE stack   High level introduction to the SAFE stack by Scott Hanselman", 
            "title": "Other Resources"
        }, 
        {
            "location": "/news/", 
            "text": "News and Announcements\n\n\n2018\n\n\n18th June\n\n\nDue to the unclear future regarding the licensing of Suave and its dependencies, the SAFE team have today made the unamimous decision to \nremove Suave as a recommended option on the SAFE stack\n. We will no longer provide guidance on integrating Suave with the SAFE stack, nor will we maintain existing capabilities for it in SAFE tooling.\n\n\nOur default recommendation for SAFE stack applications is to use Saturn or Giraffe directly, running on top of Kestel on ASP .NET.\n\n\nSAFE will continue to promote all libraries, frameworks and toolchains that provide clear and consistent licensing, do not aim to discriminate against specific libraries on a commercial basis and promote open discussion.", 
            "title": "News"
        }, 
        {
            "location": "/news/#news-and-announcements", 
            "text": "", 
            "title": "News and Announcements"
        }, 
        {
            "location": "/news/#2018", 
            "text": "", 
            "title": "2018"
        }, 
        {
            "location": "/news/#18th-june", 
            "text": "Due to the unclear future regarding the licensing of Suave and its dependencies, the SAFE team have today made the unamimous decision to  remove Suave as a recommended option on the SAFE stack . We will no longer provide guidance on integrating Suave with the SAFE stack, nor will we maintain existing capabilities for it in SAFE tooling.  Our default recommendation for SAFE stack applications is to use Saturn or Giraffe directly, running on top of Kestel on ASP .NET.  SAFE will continue to promote all libraries, frameworks and toolchains that provide clear and consistent licensing, do not aim to discriminate against specific libraries on a commercial basis and promote open discussion.", 
            "title": "18th June"
        }, 
        {
            "location": "/support/", 
            "text": "The following companies provide commercial training, support, consultancy and development services for SAFE Stack applications.\n\n\nCompositional IT\n\n\n\n\nCompositional IT are experts in designing functional-first, cloud-ready systems, offering consultancy and support, training and development. Run by an F# MVP and well-known member of the .NET community, they are dedicated to raising awareness of the benefits of both functional programming and harnessing the power of the cloud to deliver high-quality, low-cost solutions.\n\n\nLambda Factory\n\n\n\n\nLambda Factory is a consulting company specializing in designing and building complex systems using Functional Programming languages such as F#, Elm and Elixir. It also offers help with introducing functional programming and open source driven development to the organization, as well as trainings, workshops and mentoring. Founded by open source contributor and well-known member of F# Community, Lambda Factory has been committed to supporting F# Community and helping it grow.\n\n\nThe F# Community\n\n\nThe SAFE stack was written largely by the community as open source projects, such as Saturn, Giraffe, Fable and Elmish (as well as the alternative elements within the stack). All those teams are always happy to contribute and help out.\n\n\nSocial\n\n\nYou can also reach out to the SAFE team on \n@safe_stack\n or on the regular F# channels on Slack: either the official \nF# Foundation Slack\n or on the \nFunctional Programming Slack\n. We'll be expanding this over time.", 
            "title": "Support"
        }, 
        {
            "location": "/support/#compositional-it", 
            "text": "Compositional IT are experts in designing functional-first, cloud-ready systems, offering consultancy and support, training and development. Run by an F# MVP and well-known member of the .NET community, they are dedicated to raising awareness of the benefits of both functional programming and harnessing the power of the cloud to deliver high-quality, low-cost solutions.", 
            "title": "Compositional IT"
        }, 
        {
            "location": "/support/#lambda-factory", 
            "text": "Lambda Factory is a consulting company specializing in designing and building complex systems using Functional Programming languages such as F#, Elm and Elixir. It also offers help with introducing functional programming and open source driven development to the organization, as well as trainings, workshops and mentoring. Founded by open source contributor and well-known member of F# Community, Lambda Factory has been committed to supporting F# Community and helping it grow.", 
            "title": "Lambda Factory"
        }, 
        {
            "location": "/support/#the-f-community", 
            "text": "The SAFE stack was written largely by the community as open source projects, such as Saturn, Giraffe, Fable and Elmish (as well as the alternative elements within the stack). All those teams are always happy to contribute and help out.", 
            "title": "The F# Community"
        }, 
        {
            "location": "/support/#social", 
            "text": "You can also reach out to the SAFE team on  @safe_stack  or on the regular F# channels on Slack: either the official  F# Foundation Slack  or on the  Functional Programming Slack . We'll be expanding this over time.", 
            "title": "Social"
        }, 
        {
            "location": "/testimonials/", 
            "text": "Please feel free to submit a PR to add testimonials to this page!\n\n\nmsu solutions GmbH\n\n\n\n\nSAFE gives us a fast development cycle for our web and mobile platforms\n\n\n\n\nWe at \nmsu solutions GmbH\n are big fans of SAFE stack. For the last couple of years we were already using F# open source technologies for web and mobile projects. Tools like the Fable compiler and elmish are rock solid and a pleasure to work with.\n\n\nSince the release of SAFE, we see that all these important technologies are now bundled and tested under one big umbrella. \nEspecially the commercial support for SAFE is very important for us and our customers.", 
            "title": "Testimonials"
        }, 
        {
            "location": "/testimonials/#msu-solutions-gmbh", 
            "text": "SAFE gives us a fast development cycle for our web and mobile platforms   We at  msu solutions GmbH  are big fans of SAFE stack. For the last couple of years we were already using F# open source technologies for web and mobile projects. Tools like the Fable compiler and elmish are rock solid and a pleasure to work with.  Since the release of SAFE, we see that all these important technologies are now bundled and tested under one big umbrella. \nEspecially the commercial support for SAFE is very important for us and our customers.", 
            "title": "msu solutions GmbH"
        }
    ]
}